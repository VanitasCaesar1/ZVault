---
title: Security Architecture
description: How ZVault protects your secrets at every layer.
---

ZVault is built with a zero-trust architecture. Every layer assumes the layers below it may be compromised.

## The Barrier Pattern

This is the most important architectural invariant:

```
Application layer (plaintext)
        │
        ▼
   ┌─────────┐
   │ Barrier  │  ← encrypt on write, decrypt on read
   └────┬────┘
        │
        ▼
Storage layer (ciphertext only)
```

All data written to storage passes through the barrier's `encrypt()`. All data read from storage passes through `decrypt()`. The storage backend never sees plaintext.

## Seal / Unseal

ZVault starts in a sealed state. No operations are possible until it's unsealed.

1. During `zvault init`, a root key is generated and split using Shamir's Secret Sharing
2. The root key is encrypted and stored — the shares are given to operators
3. To unseal, operators submit enough shares (threshold) to reconstruct the root key
4. The root key is held in memory only — never written to disk in plaintext
5. On `zvault seal`, all key material is zeroized from memory

## Encryption

- **Algorithm**: AES-256-GCM (authenticated encryption)
- **Nonces**: Fresh 96-bit nonce from OS CSPRNG for every operation
- **Key derivation**: HKDF-SHA256 with per-engine isolation
- **Ciphertext format**: `nonce (12 bytes) || ciphertext || tag (16 bytes)`
- **At rest**: All storage is encrypted through the barrier
- **In transit**: TLS 1.3 via rustls

## Key Material Safety

- All key types derive `Zeroize` and `ZeroizeOnDrop`
- Key material never appears in logs, errors, or API responses
- `Debug` trait is manually implemented to redact sensitive fields
- Memory pages holding keys are pinned with `mlock` (no swap to disk)
- Core dumps are disabled at startup (`RLIMIT_CORE=0`)

## Token Security

- Tokens are 128-bit UUIDs from OS CSPRNG
- Stored as SHA-256 hashes — plaintext tokens are never persisted
- Comparison uses constant-time equality (`subtle::ConstantTimeEq`)
- Failed auth takes the same time as successful auth (timing-safe)

## Audit Trail

- Every secret access generates an audit entry before the response is sent
- If all audit backends fail, the request is denied (fail-closed)
- Sensitive fields are HMAC'd before writing to the audit log
- Audit log is append-only — no updates or deletes

## Dependency Security

- All cryptography from the RustCrypto ecosystem (audited, pure Rust)
- No OpenSSL, no C-backed crypto libraries
- TLS via rustls (no OpenSSL dependency)
- `cargo audit` enforced — zero known vulnerabilities policy
